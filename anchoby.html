<canvas class="webgl"></canvas>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
  import TWEEN from 'three/examples/jsm/libs/tween.module.js';

  const canvas = document.querySelector('canvas.webgl');
  const scene = new THREE.Scene();

  // Renderer
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  // Camera
  const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(1, -1, 5);
  scene.add(camera);

  const controls = new OrbitControls(camera, canvas);
  controls.enableDamping = true;

  // HDRI
  const textureLoader = new THREE.TextureLoader();
  textureLoader.load('/models/08/Rainbow3.png', (texture) => {
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
    const envMap = pmremGenerator.fromEquirectangular(texture).texture;
    scene.environment = envMap;
    scene.background = envMap;
    texture.dispose();
    pmremGenerator.dispose();
  });

  // Ambient Light
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambientLight);

  // SpotLights dinámicos
  const spotLights = [];
  const spotColors = [0xFF7F00, 0x00FF7F, 0x7F00FF];
  spotColors.forEach(color => {
    const light = new THREE.SpotLight(color, 10);
    light.castShadow = true;
    light.angle = 0.3;
    light.penumbra = 0.2;
    light.decay = 2;
    light.distance = 50;
    scene.add(light);
    spotLights.push(light);
  });

  spotLights[0].position.set(1.5, 4, 4.5);
  spotLights[1].position.set(0, 4, 3.5);
  spotLights[2].position.set(-1.5, 4, 4.5);

  // Bloom
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.3, 0.4, 0.85);
  composer.addPass(bloomPass);

  // Cargar modelo
  const loader = new GLTFLoader();
  let sceneModel = null;

  loader.load(
    '/models/08/scene.gltf',
    (gltf) => {
      sceneModel = gltf.scene;
      sceneModel.scale.set(1, 1, 1);
      sceneModel.position.set(0, -1, 0);
      sceneModel.traverse((child) => {
        if (child.isMesh && child.material) {
          child.material.transparent = true;
          child.material.side = THREE.DoubleSide;
        }
      });
      scene.add(sceneModel);
    },
    undefined,
    (error) => console.error('Error cargando scene.gltf:', error)
  );

  // Rotación al click
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let rotating = false;
  let rotationTarget = 0;
  let rotationStart = 0;
  let rotationDuration = 2;
  let rotationElapsed = 0;

  window.addEventListener('click', (event) => {
    if (!sceneModel) return;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(sceneModel, true);
    if (intersects.length > 0) {
      rotating = true;
      rotationStart = sceneModel.rotation.y;
      rotationTarget = rotationStart + Math.PI * 6;
      rotationElapsed = 0;
      spotLights.forEach(l => l.intensity += 2);
    }
  });

  // Tween spots
  function tweenSpot(light) {
    new TWEEN.Tween(light).to({
      angle: (Math.random() * 0.7) + 0.1,
      penumbra: Math.random() * 0.5 + 0.1
    }, Math.random() * 3000 + 2000)
    .easing(TWEEN.Easing.Quadratic.Out)
    .start();

    new TWEEN.Tween(light.position).to({
      x: (Math.random() * 3) - 1.5,
      y: (Math.random() * 1) + 1.5,
      z: (Math.random() * 3) - 1.5
    }, Math.random() * 3000 + 2000)
    .easing(TWEEN.Easing.Quadratic.Out)
    .start();
  }

  function updateTweens() {
    spotLights.forEach(l => tweenSpot(l));
    setTimeout(updateTweens, 5000);
  }
  updateTweens();

  // --- SISTEMA DE PARTÍCULAS --- //
  let particles = null;
  let particleMaterial = null;
  let particleGeometry = null;
  let velocities = null;
  let particleActive = false;
  let particleStartTime = 0;

  function spawnParticles(position) {
    if (particles) {
      scene.remove(particles);
      particleGeometry.dispose();
      particleMaterial.dispose();
    }

    const count = 600;
    particleGeometry = new THREE.BufferGeometry();
    
    const positions = new Float32Array(count * 3);
    velocities = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);

    for (let i = 0; i < count; i++) {
      const i3 = i * 3;

      positions[i3 + 0] = position.x;
      positions[i3 + 1] = position.y + 0.5;
      positions[i3 + 2] = position.z;

      const angle = Math.random() * Math.PI * 2;
      const speed = Math.random() * 3 + 1;
      velocities[i3 + 0] = Math.cos(angle) * speed;
      velocities[i3 + 1] = (Math.random() - 0.5) * 3;
      velocities[i3 + 2] = Math.sin(angle) * speed;

      colors[i3 + 0] = Math.random();
      colors[i3 + 1] = Math.random();
      colors[i3 + 2] = Math.random();
    }

    particleGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    particleGeometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

    particleMaterial = new THREE.PointsMaterial({
      size: 0.12,
      vertexColors: true,
      transparent: true,
      opacity: 1,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);

    particleStartTime = clock.getElapsedTime();
    particleActive = true;
  }

  window.addEventListener("keydown", (e) => {
    if (e.code === "Space" && sceneModel) {
      const pos = sceneModel.position.clone();
      spawnParticles(pos);
    }
  });

  // Animación
  const clock = new THREE.Clock();

  const animate = () => {
    const delta = clock.getDelta();
    const elapsed = clock.getElapsedTime();

    if (rotating && sceneModel) {
      rotationElapsed += delta;
      const t = Math.min(rotationElapsed / rotationDuration, 1);
      sceneModel.rotation.y = rotationStart + (rotationTarget - rotationStart) * t;
      if (t >= 1) rotating = false;
    }

    // Luz dinámica
    spotLights.forEach(light => {
      light.color.offsetHSL(0.0005, 0, 0);
      light.intensity = 5 + 2 * Math.sin(elapsed * 2);
    });

    // --- ANIMACIÓN DE PARTÍCULAS --- //
    if (particleActive && particles) {
      const tPart = elapsed - particleStartTime;

      const positions = particleGeometry.attributes.position.array;
      const count = positions.length / 3;

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;

        positions[i3 + 0] += velocities[i3 + 0] * 0.02;
        positions[i3 + 1] += velocities[i3 + 1] * 0.02;
        positions[i3 + 2] += velocities[i3 + 2] * 0.02;
      }

      particleGeometry.attributes.position.needsUpdate = true;

      particleMaterial.opacity = 1 - tPart * 0.6;

      if (particleMaterial.opacity <= 0) {
        scene.remove(particles);
        particles = null;
        particleActive = false;
      }
    }

    controls.update();
    TWEEN.update();
    composer.render();
    requestAnimationFrame(animate);
  };
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
